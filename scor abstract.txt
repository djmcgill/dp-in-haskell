Over the last decade CPU speed has increased by many orders of magnitude yet the speed of the typical programmer has not. In some cases (e.g. when prototyping new heuristics or algorithms) it is far more important to quickly produce reliable and stable code than to eke out every possible optimisation from the program itself. There have been high profile cases recently in which a software bug has caused erroneous results to be published.

This paper will investigate the use of Haskell to perform standard dynamic programming algorithms including bounded and unbounded knapsack, branch and cut, and column generation. It will compare to two of the languages most in use today (Java and C) in terms of speed, conciseness, modularity and ease of parallelisation, refactoring and debugging. The code structure will be reasonably similar across the languages except when taking advantage of specific language features (e.g. pointers, objects or laziness). The implementation is somewhat idiomatic and representative of an 'average' user - without nonportable (so called "ninja") micro-optimisations and in particular, standard libraries will be used for floating-point arithmetic and non-trivial data structures.

The preliminary results (unbounded knapsack in C and Haskell) show that the C code is about 4 times faster while being more than twice as many lines of code and took far more than twice the time to implement. Haskell's type system prevented some errors (e.g. mixing up Values and Weights) while was no help against others (e.g. incorrect array indices).
