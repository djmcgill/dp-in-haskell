\section{Results and Conclusions}

Our findings so far suggest that functional languages supported by mature
implementations can indeed speed up development by allowing implementations to
stay close to specifications, taking advantage of specific language features
such as laziness, and eliminating certain classes of errors, without incurring
a performance penalty that is unacceptable for prototypes. Our
benchmark results for unbounded knapsack suggest that the C
code is not more than about five times faster than the Haskell version.

There are a wide range of languages that provide a transition path to more functional code: features such as first-class and anonymous functions, folds and pattern-matching have been added to object-orientated languages like Java, C\#, Scala and C++, F\# and Clojure can interface seamlessly with C\# and Java respectively, and Haskell can interoperate with C with ease. As such the authors recommend that readers familiarise themselves with these idioms and consider using them in their OR prototypes and implementations.
