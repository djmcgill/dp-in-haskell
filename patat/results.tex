\section{Results and Conclusions}

Our findings so far suggest that functional languages supported by mature
implementations indeed can speed up development by allowing implementations to
stay close to specifications, taking advantage of specific language features
such as laziness, and eliminating certain classes of errors, without incurring
a performance penalty that is unacceptable for prototypes. Our present
benchmark results (unbounded knapsack in C and Haskell) suggest that the C
code is not more than about four times faster that the Haskell version.

There are a wide range of languages that provide a transition path to more functional code - features such as first-class and anonymous functions, folds and pattern-matching have been added to object-orientated languages like Java, C\#, Scala and C++. F\# and Clojure can interface seamlessly with C\# and Java respectively and it's trivial to call C code from Haskell\cite{ffi}, so it is simply not true to say that functional programming is an ivory tower or is disconnected from real-world applications. As such the authors recommend that readers consider using these features in their OR prototypes and implementations.
