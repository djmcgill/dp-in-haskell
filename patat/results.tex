\section{Results and Conclusions}

Our findings so far suggest that functional languages supported by mature
implementations can indeed speed up development by allowing implementations to
stay close to specifications, taking advantage of specific language features
such as laziness, and eliminating certain classes of errors. Furthermore, they
can achieve this without incurring
a performance penalty that is unacceptable for prototypes. Our
benchmark results for unbounded knapsack suggest that the C
code is not more than about five times faster than the Haskell version.
There are a wide range of languages that provide a transition path to more functional code as first-class and anonymous functions, folds and pattern-matching and other features have been added to object-oriented languages such as Java, C\#, Scala and C++. F\# and Clojure can interface seamlessly with C\# and Java respectively, and both Haskell and Rust can easily interoperate with C. As such the authors recommend that readers familiarise themselves with these idioms and consider using them in their OR prototypes and implementations.
