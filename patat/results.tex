\section{Results and Conclusions}

Our findings so far suggest that functional languages supported by mature
implementations indeed can speed up development by allowing implementations to
stay close to specifications, taking advantage of specific language features
such as laziness, and eliminating certain classes of errors, without incurring
a performance penalty that is unacceptable for prototypes. Our present
benchmark results (unbounded knapsack in C and Haskell) suggest that the C
code is not more than about four times faster that the Haskell version.

\textbf{TODO:} Graph of knapsack results here? gcc -O2 vs ghc-O2

\textbf{TODO:} Work on the phrasing of the conclusions below.

Even if not intending to move to FP, then techniques originatinng from 
FP, such as patterns for rules, and first class functions  along with 
techniques such as fold, are making their way into "standard" languages 
(Scala, F\#, etc) should be considered for use in OR prototypes and 
implementations.
