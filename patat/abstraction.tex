% \section{Abstraction Of Common Patterns}
% \section{Folds: an example of functional refactoring}
\section{An Illustrative Example}

In a recent high profile case \cite{Herndon13}, a spreadsheet bug caused
erroneous results from an economical analysis to be published, possibly
influencing European policy%
\footnote{\url{www.bbc.co.uk/news/magazine-22223190}}.
The error was partly caused by an indexing mistake that accidentally excluded
several countries from the analysis, an example of operational details causing
problems.

As an analogy, consider summing a collection of numbers. In a declarative
language like Haskell, the collection of numbers (whether an array, a list or
otherwise) is simply passed to the \emph{sum} function. Indexing and
element-wise operations take place behind the scenes, completely eliminating
indexing errors. By contrast, in most spreadsheets, the range of cells to
be summed must be manually selected (e.g., ``C3:C100'')%
\footnote{While named ranges do exist, they still have to be manually specified
which just pushes the problem elsewhere.}.
This is error-prone, especially if ranges later need to be modified to
accommodate additional data.

Let us consider how similar ideas might improve a combinatorial
optimisation algorithm. Solving the unbounded knapsack problem involves
finding the Greatest Common Divisor (gcd) of an array $\vec{W}$ of $n$
weights. The function $gcd$ (which takes two integers and returns the
largest integer dividing them both) is associative. Thus:
\[
gcd (\vec{W}_0, \ldots, \vec{W}_{n-1}) =
gcd(\vec{W}_0,gcd(\vec{W}_1, \ldots,gcd (\vec{W}_{n-2},\vec{W}_{n-1})\cdots))
\]
As we can see, $gcd$ is applied pairwise to the capacity and each weight,
reducing to a single integer after $n$ calls. Figure \ref{fig:gcds:java} shows
the algorithm implemented in Java. Iteration over the elements has been
abstracted into a \emph{for-each} loop, avoiding having to specify the bounds
of the loop and explicit indexing into the array at the cost of some
flexibility. The accumulator variable $gcd\_all$ is initialised to
$capacity$ and then $gcd$'d with each weight, updating the accumulator
variable with the result of $gcd$ for each new $\vec{W}_i$. The C version of
the algorithm is almost identical, except that the indexing in that case has
to be done explicitly, adding further operational details. We omit it for
reasons of space.

Figure \ref{fig:gcds:haskell}) shows the Haskell version. Here the idiom
of of reducing a list by a binary function and accumulator is captured
by the function \lstinline|foldr1|. There is thus no need for the programmer
to specify the range of the loop or how the accumulator should be updated,
reducing the number of places where mistakes might be made.

Furthermore, since the definition of $gcd$ contains the rule
`\lstinline|gcd 1 _ = 1|',
which states that $\forall x. gcd (1, x) = 1$, it can be said to be
\emph{short-circuiting}; i.e., if the first argument is equal to 1 then, due
to lazy evaluation, the second argument is not inspected and is ignored.
Therefore $gcds$ will automatically stop once a $1$ is encountered without any
change to the loop itself. Achieving the same optimisation in Java (or C) wold
require fusing the definition of $gcd$ with the loop code, which would break
modularity, hamper reuse, and render the code significantly less readable.

% \begin{figure}
% \lstinputlisting[language=c, firstline=5, lastline=11]{code/gcds.c}
% \caption{C99}
% \label{fig:gcds:c}
% \end{figure}

\begin{figure}
\lstinputlisting[language=java, firstline=3, lastline=9]{code/gcds.java}
\caption{Java 7}
\label{fig:gcds:java}
\end{figure}

\begin{figure}
\lstinputlisting[language=haskell, firstline=3, lastline=9]{code/gcds.hs}
\caption{Haskell}
\label{fig:gcds:haskell}
\end{figure}





